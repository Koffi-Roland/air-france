package com.afklm.cati.common.criteria;

import org.apache.commons.lang3.StringUtils;

import javax.validation.constraints.NotNull;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Criteria used when a RefPreferenceKeyType operation is called. Contains all the information needed
 * for RePfPreferenceKeyTypeService.
 *
 * @author M436128
 */
public class RefPreferenceKeyTypeCriteria {
	
	/**
	 * can be null : it will be generated by the service concerned
	 * but in case of update it shouldn't be null
	 */
	private Integer refId;

	@NotNull
    private String key;

	@NotNull
    private Integer minLength;

	@NotNull
    private Integer maxLength;

	@NotNull
    private String dataType;

	@NotNull
    private String condition;

    /**
     * all preference type ids linked to key, could be many or single id(s)
     */
	@NotNull
    private List<String> preferenceTypes;
	
	
    /**
     * RefPreferenceKeyTypeCriteria 
     * @param refId REFID
     * @param key SKEY
     * @param maxLength IMAX_LENGTH
     * @param minLength IMIN_LENGTH
     * @param dataType SDATA_TYPE
     * @param condition SCONDITION
     * @param preferenceTypes list of STYPE
     */
    public RefPreferenceKeyTypeCriteria(Integer refId, String key, Integer maxLength, Integer minLength,
                    String dataType, String condition, List<String> preferenceTypes) {
    	this(key,maxLength, minLength, dataType, condition, preferenceTypes);
        setRefId(refId);
    }
    
    /**
     * RefPreferenceKeyTypeCriteria 
     * @param key SKEY
     * @param maxLength IMAX_LENGTH
     * @param minLength IMIN_LENGTH
     * @param dataType SDATA_TYPE
     * @param condition SCONDITION
     * @param preferenceTypes list of STYPE
     */
    public RefPreferenceKeyTypeCriteria(String key, Integer maxLength, Integer minLength,
            String dataType, String condition, List<String> preferenceTypes) {
    	setKey(key);
    	setMaxLength(maxLength);
    	setMinLength(minLength);
    	setDataType(dataType);
    	setCondition(condition);
    	setPreferenceTypes(preferenceTypes);
	}
    
    
    public void setPreferenceTypes(List<String> preferenceType) {
        this.preferenceTypes = preferenceType.stream()
        		.map(prefType -> verifyStringValidity(prefType,"preferenceType", 3, 3, StringUtils.isAlpha(prefType)))
        		.collect(Collectors.toList());
    }
    
    public void setRefId(Integer refId) {
		this.refId = verifyIntegerValidity(refId, "refId", 3, 1);
    }

    public void setKey(String key) {
        this.key = verifyStringValidity(key, "key", 100, 0, true);
    }

    public void setMinLength(Integer minLength) {
        this.minLength = verifyIntegerValidity(minLength, "minLength", 12, 1);
    }

    public void setMaxLength(Integer maxLength) {
        this.maxLength = verifyIntegerValidity(maxLength, "maxLength", 12, 1);
    }

    public void setDataType(String dataType) {
        this.dataType = verifyStringValidity(dataType, "dataType", 25, 1, true);
    }

    public void setCondition(String condition) {
        this.condition = verifyStringValidity(condition, "condition", 1,1, condition != null && (condition.equals("M") || condition.equals("O")));
    }
    
    /**
     * check size of input string
	 * throw exception if not valid 
	 * 
	 * @param data
	 * @param fieldName
	 * @param maxLength
	 * @param minLength
	 * @param isAdditionalConditionValid if more
	 * @return
	 */
    private String verifyStringValidity(String data, String fieldName, int maxLength, int minLength, boolean isAdditionalConditionValid) {
        if (StringUtils.isNoneBlank(data) && isAdditionalConditionValid) {
        	String dataTrimed = data.trim();
        	if(dataTrimed.length() <= maxLength && dataTrimed.length() >= minLength){
        		return dataTrimed;
        	}
        }
        throw new IllegalArgumentException(data + " is not a valid argument for " + fieldName);
    }
    
    /**
     * check character's size of Integer data
     * throw exception if not valid
     * 
     * @param data
     * @param fieldName
     * @param maxLength
     * @param minLength
     * @return
     */
    private Integer verifyIntegerValidity(Integer data, String fieldName, int maxLength, int minLength) {
        if (data != null && data >= 0) {
        	int length = String.valueOf(data).length();
        	if(length <= maxLength && length >= minLength){
        		return data;
        	}
        }
        throw new IllegalArgumentException(data + " is not a valid argument for " + fieldName);
    }
    
    

    public String getPreferenceType(int index) {
        return preferenceTypes.get(index);
    }

    public String getUniquePreferenceType() {
        return preferenceTypes.get(0);
    }

    public List<String> getAllPreferenceType() {
        return preferenceTypes;
    }

    public Integer getRefId() {
        return refId;
    }

    public String getKey() {
        return key;
    }

    public Integer getMinLength() {
        return minLength;
    }

    public Integer getMaxLength() {
        return maxLength;
    }

    public String getDataType() {
        return dataType;
    }

    public String getCondition() {
        return condition;
    }

}
