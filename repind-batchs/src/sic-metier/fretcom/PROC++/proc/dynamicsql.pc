/*******************************************************************
Sample Program 10:  Dynamic SQL Method 4

This program connects you to ORACLE using your username and
password, then prompts you for a SQL statement.  You can enter
any legal SQL statement.  Use regular SQL syntax, not embedded SQL.
Your statement will be processed.  If it is a query, the rows
fetched are displayed.
You can enter multi-line statements.  The limit is 1023 characters.
This sample program only processes up to MAX_ITEMS bind variables and
MAX_ITEMS select-list items.  MAX_ITEMS is #defined to be 40.
*******************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#ifndef _INTERFACE_ORACLE_H
#define _INTERFACE_ORACLE_H
#include <sqlca.h>
#include <sqlda.h>
#endif

/* Maximum number of select-list items or bind variables. */
//JMA : 28/10/10 : Homegenisation du code
#define MAX_ITEMS         80
/* #define MAX_ITEMS         60 */
/* #define MAX_ITEMS         40 */

/* Maximum lengths of the _names_ of the
   select-list items or indicator variables. */
#define MAX_VNAME_LEN     50
#define MAX_INAME_LEN     50

#ifndef NULL
#define NULL  0
#endif
/*
EXEC SQL INCLUDE sqlca;
EXEC SQL INCLUDE sqlda;
*/
unsigned int size = 50;

char *dml_commands[] = {"SELECT", "select", "INSERT", "insert",
                        "UPDATE", "update", "DELETE", "delete"};



/* 
EXEC SQL INCLUDE sqlca;
EXEC SQL INCLUDE sqlda;
*/

SQLDA *bind_dp;
SQLDA *select_dp;

SQLDA *binda;

extern SQLDA *sqlald();
extern void sqlnul();



EXEC SQL BEGIN DECLARE SECTION;
    char    sql_statement[4096];
    EXEC SQL VAR sql_statement IS STRING(4096);
EXEC SQL END DECLARE SECTION;


/* Define a buffer to hold longjmp state info. */
jmp_buf jmp_continue;

char db_name [20];

/* variable d'environnement pour passer en mode TRACE */
char* sqlTrace = "SQL_TRACE_FYIELD";


unsigned long getSqlContext() { return sqlctx; }
void setSqlContext(unsigned long context) { sqlctx = context; }


oracle_connect(char* name,char* pass,char* db_name,char* db_link)
{  
    char* env = NULL;

    EXEC SQL WHENEVER SQLERROR GOTO connect_error;

    if (db_link)
      EXEC SQL CONNECT :name IDENTIFIED BY :pass AT :db_name USING :db_link;
    else
      EXEC SQL CONNECT :name IDENTIFIED BY :pass AT :db_name;

    env = getenv(sqlTrace);

    if (env) 
      EXEC SQL AT :db_name ALTER SESSION SET SQL_TRACE TRUE;    

    return 0;

connect_error:
    return sqlca.sqlcode;
}

execute_immediate(char* db, const char* sql) {
    EXEC SQL WHENEVER SQLERROR GOTO execute_immediate_error;
    EXEC SQL at :db EXECUTE IMMEDIATE :sql;
    return 0;
execute_immediate_error:
    return sqlca.sqlcode;
}

char* get_sql_statement()
{
    char *cp, linebuf[256];
    int iter, plsql;
    int help();
    int i = setjmp(jmp_continue);

    for (plsql = 0, iter = 1; ;)
    {
        if (iter == 1)
        {
            printf("\nSQL> ");
            sql_statement[0] = '\0';
        }
        
        fgets(linebuf, sizeof linebuf, stdin);
        fflush(stdin);

        cp = strrchr(linebuf, '\n');
        if (cp && cp != linebuf)
            *cp = ' ';
        else if (cp == linebuf)
            continue;

        if ((strncmp(linebuf, "EXIT", 4) == 0) ||
            (strncmp(linebuf, "exit", 4) == 0))
        {
            exit(-1);
        }

        else if (linebuf[0] == '?' ||
            (strncmp(linebuf, "HELP", 4) == 0) ||
            (strncmp(linebuf, "help", 4) == 0))
        {
            help();
            iter = 1;
            continue;
        }

        if (strstr(linebuf, "BEGIN") ||
            (strstr(linebuf, "begin")))
        {
            plsql = 1;
        }

        strcat(sql_statement, linebuf);

        if ((plsql && (cp = strrchr(sql_statement, '/'))) ||
            (!plsql && (cp = strrchr(sql_statement, ';'))))
        {
            *cp = '\0';
            break;
        }
        else
        {
            iter++;
            printf("%3d  ", iter);
        }
    }
    return sql_statement;
}


int execSql(char* db,
	    SQLDA* bind_dp,
	    SQLDA* select_dp,
	    char* ordreSql,
	    int simpleFetch) {

  int i=0;
   
  strcpy(sql_statement,ordreSql);

  /* Prepare the statement and declare a cursor. */
  EXEC SQL WHENEVER SQLERROR GOTO execSql_end;

  EXEC SQL AT :db PREPARE S FROM :sql_statement;

  EXEC SQL AT :db DECLARE C CURSOR FOR S;
  
  /* Set the bind variables for any placeholders in the
     SQL statement. */
  set_bind_variables(db,bind_dp);
  
  /* Open the cursor and execute the statement.
   * If the statement is not a query (SELECT), the
   * statement processing is completed after the
   * OPEN.
   */
  
  EXEC SQL AT :db OPEN C USING DESCRIPTOR bind_dp;
  
  /* Call the function that processes the select-list.
   * If the statement is not a query, this function
   * just returns, doing nothing.
   */
  process_select_list(db,bind_dp,select_dp,simpleFetch);

execSql_end:
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  i =  sqlca.sqlcode;
  if (!simpleFetch)  close_cursor(db);
  return sqlca.sqlcode = i; 
}


alloc_descriptors(SQLDA **_bind_dp,SQLDA **_select_dp)
{
    int i;

    /*
     * The first sqlald parameter determines the maximum number of
     * array elements in each variable in the descriptor. In
     * other words, it determines the maximum number of bind
     * variables or select-list items in the SQL statement.
     *
     * The second parameter determines the maximum length of
     * strings used to hold the names of select-list items
     * or placeholders.  The maximum length of column 
     * names in ORACLE is 30, but you can allocate more or less
     * as needed.
     *
     * The third parameter determines the maximum length of
     * strings used to hold the names of any indicator
     * variables.  To follow ORACLE standards, the maximum
     * length of these should be 30.  But, you can allocate
     * more or less as needed.
     */

    if ((bind_dp =
            sqlald(MAX_ITEMS, MAX_VNAME_LEN, MAX_INAME_LEN)) == (SQLDA *) 0)
    {
        fprintf(stderr,
            "Cannot allocate memory for bind descriptor.");
        return -1;  /* Have to exit in this case. */
    }

    if ((select_dp =
        sqlald (MAX_ITEMS, MAX_VNAME_LEN, MAX_INAME_LEN)) == (SQLDA *) 0)
    {
        fprintf(stderr,
            "Cannot allocate memory for select descriptor.");
        return -1;
    }
    select_dp->N = MAX_ITEMS;

    /* Allocate the pointers to the indicator variables, and the
       actual data. */
    for (i = 0; i < MAX_ITEMS; i++) {
        bind_dp->I[i] = (short *) malloc(sizeof (short));
        select_dp->I[i] = (short *) 0; /* malloc(sizeof(short)); */
        bind_dp->V[i] = (char *)  0; /* malloc(1); */
        select_dp->V[i] = (char *) 0;  /* malloc(1); */
    }
       
    *_bind_dp = bind_dp;
    *_select_dp = select_dp;

    return 0;
}


void desalloc_descriptors(SQLDA* bind_dp,SQLDA* select_dp) {
  int i;
 
  for ( i = 0; i < MAX_ITEMS; i++) 
    {    
/*       if (bind_dp->V[i] != (char *) 0)  */
/*  	free(bind_dp->V[i]);  */
      if (bind_dp->I[i] != (short *) 0)
	free(bind_dp->I[i]); 
    }

  for ( i = 0; i < select_dp->N; i++) 
    {
      if (select_dp->V[i] != (char *) 0)
	free(select_dp->V[i]);
      if (select_dp->V[i] != (char *) 0)
	free(select_dp->I[i]); 
    }

  sqlclu(bind_dp);
  sqlclu(select_dp);
}


int set_bind_variables(char* db,SQLDA* bind_dp)
{
    int i, n;
    char bind_var[64];

    /* Describe any bind variables (input host variables) */
    EXEC SQL WHENEVER SQLERROR GOTO set_bind_variables_end;

    bind_dp->N = MAX_ITEMS;  /* Initialize count of array elements. */
    EXEC SQL AT :db DESCRIBE BIND VARIABLES FOR S INTO bind_dp;

    /* If F is negative, there were more bind variables
       than originally allocated by sqlald(). */
    if (bind_dp->F < 0)
    {
        printf ("\nToo many bind variables (%d), maximum is %d\n.",
                    -bind_dp->F, MAX_ITEMS);
        return -1;
    }

    /* Set the maximum number of array elements in the
       descriptor to the number found. */
    bind_dp->N = bind_dp->F;
 
    /* Get the value of each bind variable as a
     * character string.
     *   
     * C[i] contains the length of the bind variable
     *      name used in the SQL statement.
     * S[i] contains the actual name of the bind variable
     *      used in the SQL statement.
     *
     * L[i] will contain the length of the data value
     *      entered.
     *
     * V[i] will contain the address of the data value
     *      entered.
     *
     * T[i] is always set to 1 because in this sample program
     *      data values for all bind variables are entered
     *      as character strings.
     *      ORACLE converts to the table value from CHAR.
     *
     * I[i] will point to the indicator value, which is
     *      set to -1 when the bind variable value is "null".
     */

 
    
    for (i = 0; i < bind_dp->F; i++)
    {
        printf ("\nEnter value for bind variable %.*s:  ",
               (int)bind_dp->C[i], bind_dp->S[i]);
        fgets(bind_var, sizeof bind_var, stdin);

        n = strlen(bind_var) - 1;

        bind_dp->L[i] = n;
	
/* 	bind_dp->V[i] = (char *) realloc(bind_dp->V[i], */
/*                          (bind_dp->L[i] + 1));        */

 	bind_dp->V[i] = (char *) malloc(bind_dp->L[i] + 1);            

        strncpy(bind_dp->V[i], bind_var, n);

        if ((strncmp(bind_dp->V[i], "NULL", 4) == 0) ||
                (strncmp(bind_dp->V[i], "null", 4) == 0))
            *bind_dp->I[i] = -1;
        else
            *bind_dp->I[i] = 0;
    
        bind_dp->T[i] = 1;
    }    

set_bind_variables_end:
    EXEC SQL WHENEVER SQLERROR CONTINUE;        
    return 0;
}



int process_select_list(char* db,SQLDA* bind_dp,SQLDA* select_dp,int simpleFetch)
{
    int i, null_ok, precision, scale;
    int j;
 
    char** tabGeneric = (char**) 0;
    char* pteur = NULL;
    short** tabInd = (short**) 0;

    if ((strncmp(sql_statement, "SELECT", 6) != 0) &&
        (strncmp(sql_statement, "select", 6) != 0))
    {
        select_dp->F = 0;
        return -1;
    }


    /* If the SQL statement is a SELECT, describe the
        select-list items.  The DESCRIBE function returns
        their names, datatypes, lengths (including precision
        and scale), and NULL/NOT NULL statuses. */

    select_dp->N = MAX_ITEMS;
    
    EXEC SQL AT :db  DESCRIBE SELECT LIST FOR S INTO select_dp;

    /* If F is negative, there were more select-list
       items than originally allocated by sqlald(). */
    if (select_dp->F < 0)
    {
        printf ("\nToo many select-list items (%d), maximum is %d\n",
                -(select_dp->F), MAX_ITEMS);
        return -1;
    }

    /* Set the maximum number of array elements in the
       descriptor to the number found. */

    select_dp->N = select_dp->F;

    /* Allocate storage for each select-list item.
  
       sqlprc() is used to extract precision and scale
       from the length (select_dp->L[i]).

       sqlnul() is used to reset the high-order bit of
       the datatype and to check whether the column
       is NOT NULL.

       CHAR    datatypes have length, but zero precision and
               scale.  The length is defined at CREATE time.

       NUMBER  datatypes have precision and scale only if
               defined at CREATE time.  If the column
               definition was just NUMBER, the precision
               and scale are zero, and you must allocate
               the required maximum length.

       DATE    datatypes return a length of 7 if the default
               format is used.  This should be increased to
               9 to store the actual date character string.
               If you use the TO_CHAR function, the maximum
               length could be 75, but will probably be less
               (you can see the effects of this in SQL*Plus).

       ROWID   datatype always returns a fixed length of 18 if
               coerced to CHAR.

       LONG and
       LONG RAW datatypes return a length of 0 (zero),
               so you need to set a maximum.  In this example,
               it is 240 characters.

       */

    
    for (i = 0; i < select_dp->F; i++)
    {
        /* Turn off high-order bit of datatype (in this example,
           it does not matter if the column is NOT NULL). */
        sqlnul (&(select_dp->T[i]), &(select_dp->T[i]), &null_ok);

        switch (select_dp->T[i])
        {
            case  1 : /* CHAR datatype: no change in length
                         needed, except possibly for TO_CHAR
                         conversions (not handled here). */
                break;
            case  2 : /* NUMBER datatype: use sqlprc() to
                         extract precision and scale. */
                sqlprc (&(select_dp->L[i]), &precision, &scale);
                      /* Allow for maximum size of NUMBER. */
                if (precision == 0) precision = 40;
                      /* Also allow for decimal point and
                         possible sign. */
                if (scale > 0)
                    select_dp->L[i] = precision + 2;
                else
                    select_dp->L[i] = precision;
                break;

            case  8 : /* LONG datatype */
                select_dp->L[i] = 240;
                break;

            case 11 : /* ROWID datatype */
                select_dp->L[i] = 19;
                break;

            case 12 : /* DATE datatype */
	      /*                 select_dp->L[i] = 9; */
                select_dp->L[i] = 19;   /* CB020797 */
                break;
 
            case 23 : /* RAW datatype */
                break;

            case 24 : /* LONG RAW datatype */
                select_dp->L[i] = 240;
                break;
        }
        /* Allocate space for the select-list data values.
           sqlald() reserves a pointer location for
           V[i] but does not allocate the full space for
           the pointer.  */

        /* Print column headings, right-justifying number
            column headings. */

/*         if (select_dp->T[i] == 2) */
/*             printf ("%.*s ", select_dp->M[i], select_dp->S[i]); */
/*         else */
/*             printf ("%-.*s ", select_dp->M[i], select_dp->S[i]); */

        /* Coerce ALL datatypes except for LONG RAW to
           character. */
        if (select_dp->T[i] != 24)
            select_dp->T[i] = 1;
    }
 
    /* gestion des fetch ligne a ligne */

    if (simpleFetch) {
      for (i = 0; i < select_dp->F; i++) 
	/* select_dp->V[i] = (char *) realloc(select_dp->V[i],select_dp->L[i] + 1);  */
	select_dp->V[i] = (char *) malloc(select_dp->L[i] + 1);  
	select_dp->I[i] = (short*) malloc(sizeof(short));  
       return 0;
    }


    /*

      gestion dynamique de la zone receptrice pour les datas

     */

    tabGeneric = (char** ) malloc(select_dp->N * sizeof(char*));
    tabInd = (short** ) malloc(select_dp->N * sizeof(short*));

    for (i = 0; i <  select_dp->N ; i++) {
      tabGeneric[i] = (char*) malloc(((select_dp->L[i]) * size)+1);
      select_dp->V[i] = (char*) tabGeneric[i];
      tabInd[i] = (short *) malloc(sizeof(short)*size);
      select_dp->I[i] = (short *) tabInd[i];
    }
 
    /* FETCH each row selected and print the column values. */
    EXEC SQL WHENEVER NOT FOUND GOTO end_select_loop;
    EXEC SQL WHENEVER SQLERROR GOTO end2_select_loop;


    for (;;)
    {
        EXEC SQL AT :db FOR :size FETCH C USING DESCRIPTOR select_dp;
	
	for (i = 0; i < select_dp->N ; i++) {
	  tabGeneric[i] = (char*) realloc(tabGeneric[i],
					  ((select_dp->L[i]) 
					  * 
					  (size + sqlca.sqlerrd[2]))
					  + 1
					  );
	  
	  select_dp->V[i] = (char*) &tabGeneric[i][(select_dp->L[i])
						 *
						 sqlca.sqlerrd[2]];
	  
	  tabInd[i] = (short *) realloc(tabInd[i],
					sizeof(short)
					* 
					(size + sqlca.sqlerrd[2]));

	  select_dp->I[i] = (short *) &tabInd[i][sqlca.sqlerrd[2]];
	  
	}       	  

        /* Since each variable returned has been coerced to a
           character string, very little processing is required
           here.  This routine just prints out the values on
           the terminal. */

    }
end_select_loop:
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    sqlca.sqlcode = 0;

    for (i = 0; i < select_dp->N ; i++) {
      tabGeneric[i] = (char*) realloc(tabGeneric[i],
				      ((select_dp->L[i]) 
				      * 
				      sqlca.sqlerrd[2])
				      + 1
				      );	  
      select_dp->V[i] = (char*) tabGeneric[i];
            
      tabInd[i] = (short *) realloc(tabInd[i],
				    sizeof(short)
				    *
				    sqlca.sqlerrd[2]);	

      select_dp->I[i] = (short *) tabInd[i];
				  
    }
    
    free(tabInd);
    free(tabGeneric);
        
    return 0;
end2_select_loop:
    free (tabInd);
    free (tabGeneric);
    EXEC SQL WHENEVER SQLERROR CONTINUE;        
    return 0;
}



int prepare_select(char* db,SQLDA* bind_dp,SQLDA* select_dp,char* sql)
{
    int i, n;
    /* Describe any bind variables (input host variables) */
    EXEC SQL WHENEVER SQLERROR GOTO end_prepare_select; 

    EXEC SQL AT :db PREPARE stmt_select FROM :sql;

    bind_dp->N = MAX_ITEMS;  /* Initialize count of array elements. */

    EXEC SQL AT :db DECLARE C1 CURSOR FOR stmt_select;  
   
    EXEC SQL AT :db DESCRIBE BIND VARIABLES FOR stmt_select INTO bind_dp;
    if (bind_dp->F < 0)
    {
        printf ("\nToo many bind variables (%d), maximum is %d\n.",
                    -bind_dp->F, MAX_ITEMS);
        return -1;
    }
    bind_dp->N = bind_dp->F;
end_prepare_select:
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return sqlca.sqlcode;
}


int prepare_sql(char* db,SQLDA* bind_dp,SQLDA* select_dp,char* sql)
{
    int i, n;
    /* Describe any bind variables (input host variables) */
    EXEC SQL WHENEVER SQLERROR GOTO end_prepare_sql;

    EXEC SQL AT :db PREPARE stmt FROM :sql;

    bind_dp->N = MAX_ITEMS;  /* Initialize count of array elements. */
    EXEC SQL AT :db DESCRIBE BIND VARIABLES FOR stmt INTO bind_dp;
    if (bind_dp->F < 0)
    {
        printf ("\nToo many bind variables (%d), maximum is %d\n.",
                    -bind_dp->F, MAX_ITEMS);
        return -1;
    }
    bind_dp->N = bind_dp->F;

end_prepare_sql:
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return sqlca.sqlcode;
}

int prepare_type(SQLDA* bind_dp,SQLDA* select_dp) {
  int i, null_ok, precision, scale;
  for (i = 0; i < select_dp->F; i++)
    {
        /* Turn off high-order bit of datatype (in this example,
           it does not matter if the column is NOT NULL). */
        sqlnul (&(select_dp->T[i]), &(select_dp->T[i]), &null_ok);

        switch (select_dp->T[i])
        {
            case  1 : /* CHAR datatype: no change in length
                         needed, except possibly for TO_CHAR
                         conversions (not handled here). */
                break;
            case  2 : /* NUMBER datatype: use sqlprc() to
                         extract precision and scale. */
                sqlprc (&(select_dp->L[i]), &precision, &scale);
                      /* Allow for maximum size of NUMBER. */
                if (precision == 0) precision = 40;
                      /* Also allow for decimal point and
                         possible sign. */
                if (scale > 0)
                    select_dp->L[i] = precision + 2;
                else
                    select_dp->L[i] = precision;
                break;

            case  8 : /* LONG datatype */
                select_dp->L[i] = 240;
                break;

            case 11 : /* ROWID datatype */
                select_dp->L[i] = 19;
                break;

            case 12 : /* DATE datatype */
                select_dp->L[i] = 19;
                break;
 
            case 23 : /* RAW datatype */
                break;

            case 24 : /* LONG RAW datatype */
                select_dp->L[i] = 240;
                break;
        }
        /* Allocate space for the select-list data values.
           sqlald() reserves a pointer location for
           V[i] but does not allocate the full space for
           the pointer.  */

        /* Print column headings, right-justifying number
            column headings. */

        /* Coerce ALL datatypes except for LONG RAW to
           character. */
        if (select_dp->T[i] != 24)
            select_dp->T[i] = 1;
    }

  /*
  for (i = 0; i < select_dp->F; i++)
    select_dp->V[i] = (char *) realloc(select_dp->V[i],select_dp->L[i] + 1);  
    */

  return 0;
}


int exec_sql(char* db,SQLDA* bind_dp,SQLDA* select_dp,int taille)
{
    EXEC SQL WHENEVER NOT FOUND GOTO end_exec_sql_not_found;
    EXEC SQL WHENEVER SQLERROR GOTO end_exec_sql;
    EXEC SQL at :db FOR :taille EXECUTE stmt USING DESCRIPTOR bind_dp;

/* Mis en commentaire par GDEC le 23/07 */
/*    EXEC SQL COMMIT WORK; */
end_exec_sql:
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    return sqlca.sqlcode;
end_exec_sql_not_found:
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    return sqlca.sqlcode = 0;
}




int readCursor(char* db,SQLDA* bind_dp,SQLDA* select_dp) {
  int i;
  EXEC SQL WHENEVER NOT FOUND GOTO end_fetch;
  EXEC SQL WHENEVER SQLERROR GOTO end_fetch1;
  //JMA : 28/10/10 : Homogeneisation du code
  sqlca.sqlcode = 0;
  EXEC SQL at :db FETCH C USING DESCRIPTOR select_dp;
end_fetch:
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  return sqlca.sqlcode = -1;
end_fetch1:
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  return sqlca.sqlcode;
}


 
help()
{
    puts("\n\nEnter a SQL statement or a PL/SQL block at the SQL> prompt.");
    puts("Statements can be continued over several lines, except");
    puts("within string literals.");
    puts("Terminate a SQL statement with a semicolon.");
    puts("Terminate a PL/SQL block (which can contain embedded semicolons)");
    puts("with a slash (/).");
    puts("Typing \"exit\" (no semicolon needed) exits the program.");
    puts("You typed \"?\" or \"help\" to get this message.\n\n");
}
 

int close_cursor(char* db) {
    /* Close the cursor. */
    EXEC SQL AT :db CLOSE C;
    return sqlca.sqlcode;
}

int commit(char* db) {
    EXEC SQL AT :db COMMIT WORK;
    return sqlca.sqlcode;
}

int rollback(char* db) {
    EXEC SQL AT :db ROLLBACK WORK;
   return sqlca.sqlcode;
}

/* savepoint par defaut */

int savepoint(char* db) {
    EXEC SQL AT :db SAVEPOINT TOTO;
    return sqlca.sqlcode;
}


int rollbacktosavepoint(char* db) {
    EXEC SQL AT :db ROLLBACK TO SAVEPOINT TOTO;
    return sqlca.sqlcode;
}


int disconnect(char* db) {
  EXEC SQL AT :db COMMIT RELEASE;
  return sqlca.sqlcode;
}

//JMA : 28/10/10 : Homogénéisation du code
exec_fetch(char* db,SQLDA* bind_dp,SQLDA* select_dp) {
  
  return 0;

}


/* int exec_select(SQLDA* bind_dp,SQLDA* select_dp) { */
exec_select(char* db,SQLDA* bind_dp,SQLDA* select_dp) {
  int i;
  long CodeError = 0;
  EXEC SQL WHENEVER SQLERROR goto end_exec_select;
  select_dp->N = MAX_ITEMS;    
  EXEC SQL AT :db OPEN C1 USING DESCRIPTOR bind_dp;
  EXEC SQL AT :db DESCRIBE SELECT LIST FOR stmt_select INTO select_dp;
  select_dp->N = select_dp->F;
  prepare_type(bind_dp,select_dp);
  process_select(db,bind_dp,select_dp);
end_exec_select:
  CodeError = sqlca.sqlcode;
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  /* Close the cursor. */
  EXEC SQL AT :db CLOSE C1; 
  sqlca.sqlcode = CodeError;
  return sqlca.sqlcode;
}   



int process_select(char* db,SQLDA* bind_dp,SQLDA* select_dp)
{
    int i, null_ok, precision, scale;
    int j;
 
    char** tabGeneric = (char**) 0;
    char* pteur = NULL;   
    short** tabInd = (short**) 0;

    tabGeneric = (char** ) malloc(select_dp->N * sizeof(char*));
    tabInd = (short** ) malloc(select_dp->N * sizeof(short*));

    for (i = 0; i <  select_dp->N ; i++) {
      tabGeneric[i] = (char*) malloc(((select_dp->L[i]) * size)+1);
      select_dp->V[i] = (char*) tabGeneric[i];
      tabInd[i] = (short *) malloc(sizeof(short)*size);
      select_dp->I[i] = (short *) tabInd[i];
    }
 
    /* FETCH each row selected and print the column values. */
    EXEC SQL WHENEVER NOT FOUND GOTO end_process_select;

    for (;;)
    {
        EXEC SQL AT :db FOR :size FETCH C1 USING DESCRIPTOR select_dp;
	
	for (i = 0; i < select_dp->N ; i++) {
	  tabGeneric[i] = (char*) realloc(tabGeneric[i],
					  ((select_dp->L[i]) 
					  * 
					  (size + sqlca.sqlerrd[2]))
					  + 1
					  );
	  
	  select_dp->V[i] = (char*) &tabGeneric[i][(select_dp->L[i])
						 *
						 sqlca.sqlerrd[2]];

	  tabInd[i] = (short *) realloc(tabInd[i],
					sizeof(short)
					* 
					(size + sqlca.sqlerrd[2]));

	  select_dp->I[i] = (short *) &tabInd[i][sqlca.sqlerrd[2]];
	}       	  

    }
end_process_select:
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    sqlca.sqlcode = 0;
    
    for (i = 0; i < select_dp->N ; i++) {
      tabGeneric[i] = (char*) realloc(tabGeneric[i],
				      ((select_dp->L[i]) 
				      * 
				      sqlca.sqlerrd[2])
				      + 1
				      );	  
      select_dp->V[i] = (char*) tabGeneric[i];

      tabInd[i] = (short *) realloc(tabInd[i],
				    sizeof(short)
				    *
				    sqlca.sqlerrd[2]);	

      select_dp->I[i] = (short *) tabInd[i];
    }
    
    free(tabInd);
    free(tabGeneric);

    return 0;
}

