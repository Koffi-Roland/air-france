/*******************************************************************
Sample Program 10:  Dynamic SQL Method 4

This program connects you to ORACLE using your username and
password, then prompts you for a SQL statement.  You can enter
any legal SQL statement.  Use regular SQL syntax, not embedded SQL.
Your statement will be processed.  If it is a query, the rows
fetched are displayed.
You can enter multi-line statements.  The limit is 1023 characters.
This sample program only processes up to MAX_ITEMS bind variables and
MAX_ITEMS select-list items.  MAX_ITEMS is #defined to be 40.
*******************************************************************/

#ifdef DEBUG_TRACE
#include <unistd.h> /* sleep */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
#include <sqlda.h>
#include <sqlcpr.h>

#include <pthread.h> /* thr_self() */

/* Maximum number of select-list items or bind variables. */
#define MAX_ITEMS 200

/* Maximum lengths of the _names_ of the
   select-list items or indicator variables. */
#define MAX_VNAME_LEN     50
#define MAX_INAME_LEN     50

#ifndef NULL
#define NULL  0
#endif

#ifdef SQL_SINGLE_RCTX
#undef SQL_SINGLE_RCTX 
#endif
#define SQL_SINGLE_RCTX (void*)0

unsigned int batchRecordSize = MAX_ITEMS ;
char *dml_commands[] = {"SELECT", "select", "INSERT", "insert",
                        "UPDATE", "update", "DELETE", "delete"};

EXEC SQL INCLUDE sqlda;
EXEC SQL INCLUDE sqlca;

EXEC SQL BEGIN DECLARE SECTION;
    char    sql_statement[4096];
    EXEC SQL VAR sql_statement IS STRING(4096);
EXEC SQL END DECLARE SECTION;
SQLDA *select_dp;

/* Define a buffer to hold longjmp state info. */
jmp_buf jmp_continue;

char db_name [20];
/*sql_context*  globalContext;*/

/* variable d'environnement pour passer en mode TRACE */
char* sqlTrace = "SQL_TRACE_FYIELD";

/* forward */
#ifdef DEBUG_TRACE
int dinb_close_cursor( char* db,
		       /* sql_context* globalContext, */
		       /*struct sqlca* localSqlca,*/
		       FILE* of );
#else
int dinb_close_cursor( char* db
		       /* sql_context* globalContext, */
		       /*struct sqlca* localSqlca*/
		       );
#endif
#ifdef DEBUG_TRACE
int dinb_process_select( char* db,
			 SQLDA* select_dp,
			 /* sql_context* globalContext, */
			 /*struct sqlca* localSqlca,*/
			 FILE* of );
#else
int dinb_process_select( char* db,
			 SQLDA* select_dp
			 /* sql_context* globalContext, */
			 /*struct sqlca* localSqlca*/
			 );
#endif

unsigned long dinb_getSqlContext() { return sqlctx; }
void dinb_setSqlContext(unsigned long context) { 
	sqlctx = context ;
}

#ifdef DEBUG_TRACE
int dinb_oracle_connect( char* name,
			 char* pass,
			 char* db_name,
			 char* db_link,
			 /* sql_context* globalContext, */
			 /*struct sqlca* localSqlca,*/
			 FILE* of ) {
#else
int dinb_oracle_connect( char* name,
			 char* pass,
			 char* db_name,
			 char* db_link
			 /* sql_context* globalContext, */
			 /*struct sqlca* localSqlca*/
			 ) {
#endif

    char* env = NULL ;
    /*    struct sqlca sqlca ;*/

#ifdef DEBUG_TRACE
      fprintf( of, "t%d - dinb_oracle_connect - get in\n", thr_self() );
      fflush( of );
#endif

    /* sql_context localContext; */
    /* localContext = *myContext; */

    /* EXEC SQL ENABLE THREADS; */

    /* EXEC SQL CONTEXT ALLOCATE :*globalContext; */
    /* EXEC SQL CONTEXT USE :*globalContext; */

    EXEC SQL WHENEVER SQLERROR GOTO connect_error;

    
    if( db_link ) {
#ifdef DEBUG_TRACE
      fprintf( of, "t%d - dinb_oracle_connect calls EXEC SQL CONNECT USING %s/%s@%s\n",
	       thr_self(), name, pass, db_name );
      fflush( of );
      /*
      fclose( of );
      printf( "sleep...\n" );
      sleep( 3 );
      if( ( of = fopen( "/tmp/mireille.log", "a" ) ) == NULL ) {
	printf( "No log file for the following...\n" );
      }
      */

#endif
      EXEC SQL CONNECT :name IDENTIFIED BY :pass AT :db_name USING :db_link;
    } else {
#ifdef DEBUG_TRACE
      fprintf( of, "t%d - dinb_oracle_connect calls EXEC SQL CONNECT %s/%s@%s\n",
	       thr_self(), name, pass, db_name );
      fflush( of );
#endif
      EXEC SQL CONNECT :name IDENTIFIED BY :pass AT :db_name;
    }

    env = getenv( sqlTrace );

    if( env ) {
#ifdef DEBUG_TRACE
      fprintf( of, "t%d - dinb_oracle_connect found env = %d so call SQL_TRACE TRUE\n",
	       thr_self(), env );
      fflush( of );
#endif
      EXEC SQL AT :db_name ALTER SESSION SET SQL_TRACE TRUE;    
    } else {
#ifdef DEBUG_TRACE
      fprintf( of, "t%d - dinb_oracle_connect found env = %d so do not call SQL_TRACE TRUE\n",
	       thr_self(), env );
      fflush( of );
#endif
    }
    
#ifdef DEBUG_TRACE
      fprintf( of, "t%d - dinb_oracle_connect - get out OK\n", thr_self() );
      fflush( of );
#endif
    return 0;

connect_error:
#ifdef DEBUG_TRACE
      fprintf( of, "t%d - dinb_oracle_connect returns error %d\n",
	       thr_self(), sqlca.sqlcode );
      fflush( of );
#endif
      /*    memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
    return sqlca.sqlcode ;
}

#ifdef DEBUG_TRACE
int dinb_alloc_descriptor( SQLDA** _select_dp,
			   FILE* of ) {
#else
int dinb_alloc_descriptor( SQLDA** _select_dp ) {
#endif

  /*
   * The first SQLSQLDAAlloc parameter is the runtime context.

   * The second parameter determines the maximum number of
   * array elements in each variable in the descriptor. In
   * other words, it determines the maximum number of bind 
   * variables or select-list items in the SQL statement.

   * The third parameter determines the maximum length of
   * strings used to hold the names of select-list items 
   * or placeholders. The maximum length of column names
   * in ORACLE is 30, but you can allocate more or less
   * as needed.

   * The fourth parameter determines the maximum length of
   * strings used to hold the names of any indicator
   * variables. To follow ORACLE standards, the maximum
   * length of these should be 30. But, you can allocate
   * more or less as needed.
   */

  int i ;

#ifdef DEBUG_TRACE
  fprintf( of, "t%d - dynamicsql.pc - dinb_alloc_descriptor\n", thr_self() );
  fflush( of );
#endif
  if( ( select_dp =
	/* SQLSQLDAAlloc( SQL_SINGLE_RCTX, MAX_ITEMS, MAX_VNAME_LEN, MAX_INAME_LEN ) ) */
	SQLSQLDAAlloc( SQL_SINGLE_RCTX, MAX_ITEMS, MAX_VNAME_LEN, 0 ) )
      /* last param 0 because it is a select descriptor and not a bind descriptor */
      == (SQLDA*) 0 ) {
#ifdef DEBUG_TRACE
    fprintf( of, "t%d - Cannot allocate memory for select descriptor\n", thr_self() );
    fflush( of );
#endif
    return -1;  /* Have to exit in this case. */
  }

#ifdef DEBUG_TRACE
  fprintf( of, "t%d - dynamicsql.pc - dinb_alloc_descriptor SQLSQLDAAlloc OK\n",
	   thr_self() );
  fflush( of );
#endif
  select_dp->N = MAX_ITEMS ;

  /* Allocate the pointers to the indicator variables, and the
     actual data. */
  for( i = 0; i < MAX_ITEMS; i++) {
    select_dp->I[i] = (short*) /* 0; */ malloc( sizeof(short) );
    select_dp->V[i] = (char*) /* 0; */ malloc( 1 );
    }

  *_select_dp = select_dp;

#ifdef DEBUG_TRACE
    fprintf( of, "t%d - dynamicsql.pc - dinb_alloc_descriptor end OK\n",
	     thr_self() );
    fflush( of );
#endif
  return 0 ;

} /* end alloc_descriptor */

void dinb_desalloc_descriptors( SQLDA* select_dp ) {

  int i ;
 
  for( i=0; i<select_dp->N; i++ ) {
    if( select_dp->V[i] != (char *) 0 ) {
      free( select_dp->V[i] );
    }
    if( select_dp->V[i] != (char *) 0 ) {
	free( select_dp->I[i] ); 
    }
  }
    
  SQLSQLDAFree( SQL_SINGLE_RCTX, select_dp );
}

#ifdef DEBUG_TRACE
int dinb_prepare_select( char* db,
			 SQLDA* select_dp,
			 char* sql,
			 /* sql_context* globalContext, */
			 /*struct sqlca* localSqlca,*/
			 FILE* of ) {
#else
int dinb_prepare_select( char* db,
			 SQLDA* select_dp,
			 char* sql
			 /* sql_context* globalContext, */
			 /*struct sqlca* localSqlca*/
			 ) {
#endif

    int i, n;
    /*    struct sqlca sqlca ;*/
    sqlca.sqlcode = 0 ;

    int rc ;
    
    /* EXEC SQL CONTEXT USE :*myContext; */

    /* Describe any bind variables (input host variables) */
    EXEC SQL WHENEVER SQLERROR GOTO end_prepare_select ;

#ifdef DEBUG_TRACE
    fprintf( of, "t%d - dinb_prepare_select calls EXEC SQL PREPARE for '%s', error_code = %d\n",
	     thr_self(), sql, sqlca.sqlcode );
    fflush( of );
#endif
    EXEC SQL AT :db PREPARE stmt_select FROM :sql ;
#ifdef DEBUG_TRACE
    fprintf( of, "t%d - dinb_prepare_select calls EXEC SQL DECLARE, error_code = %d\n",
	     thr_self(), sqlca.sqlcode );
    fflush( of );
#endif
    EXEC SQL AT :db DECLARE C1 CURSOR FOR stmt_select;
#ifdef DEBUG_TRACE
    fprintf( of, "t%d - dinb_prepare_select after EXEC SQL DECLARE, error_code = %d\n",
	     thr_self(), sqlca.sqlcode );
    fflush( of );
#endif

 end_prepare_select:
#ifdef DEBUG_TRACE
    fprintf( of, "t%d - dinb_prepare_select at end_prepare_select, error_code = %d\n",
	     thr_self(), sqlca.sqlcode );
    fflush( of );
#endif
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    /*    memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
    return sqlca.sqlcode ;
}

#ifdef DEBUG_TRACE
int dinb_prepare_sql( char* db,
		      SQLDA* select_dp,
		      char* sql,
		      /* sql_context* globalContext, */
		      /*		      struct sqlca* localSqlca,*/
		      FILE* of ) {
#else
int dinb_prepare_sql( char* db,
		      SQLDA* select_dp,
		      char* sql
		      /* sql_context* globalContext, */
		      /*		      struct sqlca* localSqlca*/
		      ) {
#endif

    int i, n;
    /*    struct sqlca sqlca;*/

#ifdef DEBUG_TRACE
    fprintf( of, "t%d - dinb_prepare_sql - get in\n", thr_self() );
    fflush( of );
#endif

    /* EXEC SQL CONTEXT USE :*myContext ; */

    /* Describe any bind variables (input host variables) */

    EXEC SQL WHENEVER SQLERROR GOTO end_prepare_sql;

    /* printf( "t%d - dinb_prepare_sql AT %s from %s\n",
       thr_self(), db, sql ); */
#ifdef DEBUG_TRACE
    fprintf( of, "t%d - dinb_prepare_sql - call PREPARE for '%s' at '%s'\n", thr_self(), sql, db );
    fflush( of );
#endif
    EXEC SQL AT :db PREPARE stmt FROM :sql ;
#ifdef DEBUG_TRACE
    fprintf( of, "t%d - dinb_prepare_sql - PREPARE succeeded\n", thr_self() );
    fflush( of );
#endif

end_prepare_sql:
    EXEC SQL WHENEVER SQLERROR CONTINUE ;

#ifdef DEBUG_TRACE
    fprintf( of, "t%d - dinb_prepare_sql - get out with error = %d\n",
	     thr_self(), sqlca.sqlcode );
    fflush( of );
#endif

    /*    memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
    return sqlca.sqlcode ;
}

int dinb_prepare_type( SQLDA* select_dp, short* type_arr,
		       int dateFormatSize ) {

  int i, null_ok, precision, scale;

  for( i = 0; i < select_dp->F; i++ ) {

    /* Turn off high-order bit of datatype (in this example,
       it does not matter if the column is NOT NULL). */

    SQLColumnNullCheck( SQL_SINGLE_RCTX,
		       (unsigned short*) &( select_dp->T[i] ),
		       (unsigned short*) &( select_dp->T[i] ),
		       &null_ok );

    type_arr[i] = select_dp->T[i] ;

    switch (select_dp->T[i]) {
    case  1 : /* CHAR datatype: no change in length
		 needed, except possibly for TO_CHAR
		 conversions (not handled here). */
      break;
    case  2 : /* NUMBER datatype: use sqlprc() to
		 extract precision and scale. */
	      /* sqlprc( (unsigned int*) &(select_dp->L[i]), &precision, &scale); */
      SQLNumberPrecV6( SQL_SINGLE_RCTX,
		       (unsigned /*long*/ int*) &(select_dp->L[i]),
		       &precision, &scale );
      /* printf( "Precision %d and scale %d\n", precision, scale ); */

      /* Allow for maximum size of NUMBER. */
      if( precision == 0 ) {
	precision = 40 ;
      }
      /* Also allow for decimal point and
	 possible sign. */

      /*      
      if( scale > 0 ) {
	select_dp->L[i] = sizeof( float ) ; /* precision + 2 ; * /
      } else {
	select_dp->L[i] = sizeof( int ) ; /* precision; * /
      }
      */
      
      /* error sqlca.sqlcode -1455 returned by process_select 
	 "converting column overflows integer datatype"
	 with T[i] = 3 
	 OK if T[i] = 1
      */
      select_dp->L[i] = precision + 2 ;
      if( scale < 0 ) {
	select_dp->L[i] += -scale ;
      }
      /* */

      /* printf( "NUMBER changed to TEXT\n" ); */
      select_dp->T[i] = 1 ;

      break;

    case  8 : /* LONG datatype */
      select_dp->L[i] = 240;
      break;
      
    case 11 : /* ROWID datatype */
      select_dp->L[i] = 18;
      break;
      
    case 12 : /* DATE datatype */
      select_dp->L[i] = dateFormatSize;/*TLG 40 ; 9 ;*/ /* 18 ; */
      select_dp->T[i] = 1 ; /* changed to VARCHAR2 */
      /* printf( "DATE changed to TEXT\n" ); */
      break;
      
    case 23 : /* RAW datatype */
      break;
      
    case 24 : /* LONG RAW datatype */
      select_dp->L[i] = 240;
      break;
    } /* end switch */

    /* Allocate space for the select-list data values.
       sqlald() reserves a pointer location for
       V[i] but does not allocate the full space for
       the pointer.  */
    /* select_dp->V[i] = malloc( select_dp->L[i+1] ); done in process_select */
    
    /* Allocate storage for indicator value */
    /* select_dp->I[i] = (short*) malloc( sizeof( short* ) ) ; done in process_select */
    
    /* Print column headings, right-justifying number
       column headings. */
    /* Coerce ALL datatypes except for LONG RAW to
       character. */


    /* GAG !!!
    if( select_dp->T[i] != 24 ) {
      select_dp->T[i] = 1 ;
    }
    */
    /*
    if( select_dp->T[i] == 2 ) {
      printf( "NUMBER changed to TEXT\n" );
      select_dp->T[i] = 1 ;
      /* the correct type is stored in type_array * /
    }
    */

    /*
    if( select_dp->T[i] == 2 ) { /* NUMBER * /
      if( scale > 0 ) {
	printf( "float\n" ); /* 4 * /
	select_dp->T[i] = 4 ;
      } else {
	printf( "int\n" ); /* 3 * /
	select_dp->T[i] = 1 ; /* 1 ; * /
      }
    }
    */
  } /* end for each column */

  /*
  for (i = 0; i < select_dp->F; i++)
    select_dp->V[i] = (char *) realloc(select_dp->V[i],select_dp->L[i] + 1);  
    */

  return 0;
}

int dinb_exec_sql( char* db, SQLDA* select_dp, int taille
		   /* sql_context* globalContext, */
		   /*		   struct sqlca* localSqlca*/
		   ) {

    /* EXEC SQL CONTEXT USE :*myContext; */
  /*  struct sqlca sqlca ;*/
  

  /* printf("DEBUG: thread %d: dinb_exec_sql called with context Ox%X\n",pthread_self(),*globalContext); */
    EXEC SQL WHENEVER NOT FOUND GOTO end_exec_sql_not_found ;
    EXEC SQL WHENEVER SQLERROR GOTO end_exec_sql ;
    EXEC SQL at :db FOR :taille EXECUTE stmt ; /* USING DESCRIPTOR bind_dp; */

    /*    memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
    return sqlca.sqlcode = 0 ;

/* Mis en commentaire par GDEC le 23/07 */
/*    EXEC SQL COMMIT WORK; */

end_exec_sql:
    EXEC SQL WHENEVER SQLERROR CONTINUE ;
    /*    memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
    return sqlca.sqlcode ;

end_exec_sql_not_found:
  printf( "dinb_exec_sql NOT FOUND, code = 0\n" );
    EXEC SQL WHENEVER NOT FOUND CONTINUE ;
    /*    memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
    return sqlca.sqlcode = 0 ;
}

int dinb_readCursor( char* db,
		     SQLDA* select_dp
		     /* sql_context* globalContext, */
		     /*		     struct sqlca* localSqlca*/
		     ) {
  int i;
  /*  struct sqlca sqlca ;*/
  /* EXEC SQL CONTEXT USE :*myContext; */

  /* printf("DEBUG: thread %d dinb_readCursor called with context Ox%X\n",pthread_self(),*globalContext); */
  EXEC SQL WHENEVER NOT FOUND GOTO end_fetch;
  EXEC SQL WHENEVER SQLERROR GOTO end_fetch1;
  EXEC SQL at :db FETCH C1 USING DESCRIPTOR select_dp;

end_fetch:
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  /*  memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
  return sqlca.sqlcode = -1 ;
end_fetch1:
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  /*  memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
  return sqlca.sqlcode ;
}

#ifdef DEBUG_TRACE
int dinb_close_cursor( char* db, /* sql_context* globalContext, */
		       /*struct sqlca* localSqlca,*/
		       FILE* of ) {
#else
int dinb_close_cursor( char* db /* sql_context* globalContext, */
		       /*struct sqlca* localSqlca*/
		       ) {
#endif
  /* Close the cursor. */
  /* EXEC SQL CONTEXT USE :*myContext; */
  /*  struct sqlca sqlca ;*/
  EXEC SQL AT :db CLOSE C1 ;
  /*  memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
#ifdef DEBUG_TRACE
  fprintf( of, "t%d - dinb_close_cursor returns error %d\n",
	   thr_self(), sqlca.sqlcode );
#endif
  return sqlca.sqlcode ;
}

int dinb_disconnect( char* db
		     /* sql_context* globalContext, */
		     /*		     struct sqlca* localSqlca*/
		     ) { 

  /* EXEC SQL CONTEXT USE :*myContext; */
#ifdef DEBUG_TRACE
  fprintf( stderr, "dinb_disconnect calls COMMIT RELEASE\n" );
  fflush( stderr );
#endif
  /*  struct sqlca sqlca ;*/
  EXEC SQL AT :db COMMIT RELEASE;
#ifdef DEBUG_TRACE
  fprintf( stderr, "dinb_disconnect after COMMIT RELEASE\n" );
  fflush( stderr );
#endif
  /* EXEC SQL CONTEXT FREE :*globalContext; */
  /*  memcpy( localSqlca,&sqlca, sizeof( struct sqlca ) );*/
#ifdef DEBUG_TRACE
  fprintf( stderr, "dinb_disconnect returns %d\n", sqlca.sqlcode );
  fflush( stderr );
#endif
  return sqlca.sqlcode ;
}

#ifdef DEBUG_TRACE
int dinb_exec_select( char* db,
		      SQLDA* select_dp,
		      short** type_array,
		      /* sql_context* globalContext, */
		      int formatDateSize,
		      /*		      struct sqlca* localSqlca,*/
		      FILE* of ) {
#else
int dinb_exec_select( char* db,
		      SQLDA* select_dp,
		      short** type_array,
		      /* sql_context* globalContext, */
		      int formatDateSize
		      /*		      struct sqlca* localSqlca*/
		      ) {
#endif

  int i;
  long CodeError = 0;
  char sqlcaKeepMsg[70] ;
  unsigned short sqlcaKeepLen ;
  /*  struct sqlca sqlca ;*/
  /* printf("DEBUG: thread %d: dinb_exec_select called with context Ox%X\n",pthread_self(),*globalContext); */
  /* EXEC SQL CONTEXT USE :*myContext; */

  EXEC SQL WHENEVER SQLERROR goto end_exec_select;
  select_dp->N = MAX_ITEMS;    
  EXEC SQL AT :db OPEN C1; /* USING DESCRIPTOR bind_dp; */
#ifdef DEBUG_TRACE
      fprintf(of, "t%d - dinb_exec_select - open cursor C1\n", thr_self() );
      fflush( of );
#endif
  EXEC SQL AT :db DESCRIBE SELECT LIST FOR stmt_select INTO select_dp;
    

  /* if F is negative, there were more select-list 
   * items than originally allocated by SQASQLDAAlloc(). */
  
  if( select_dp->F < 0 ) {
    printf( "Too many select-list items (%d), maximum is %d\n",
	    -( select_dp->F ), MAX_ITEMS );
    CodeError = 99 ; /* added by Mireille 06/02/06 */
    return CodeError ;
  } else {
  }
  
  select_dp->N = select_dp->F;
  if( *type_array ) {
    free( *type_array );
  }
  /* type_array = new short[select_dp->F] ; */
  *type_array = (short*) malloc( select_dp->F * sizeof( short ) );
  dinb_prepare_type( select_dp, *type_array, formatDateSize );
  /* printf( "dynamicsql.pc - after prepare_type, calls process_select\n" ); */
  /* process_select(db,bind_dp,select_dp); */
  /* printf("DEBUG: thread %d dinb_exec_select: calling  dinb_process_select with context Ox%X\n",pthread_self(),*globalContext); */
#ifdef DEBUG_TRACE
  dinb_process_select( db, select_dp, /* globalContext,  &sqlca,*/ of );
  fprintf( of, "t%d - dinb_exec_select - after process_select, end exec_select with error %d\n",
	   thr_self(), sqlca.sqlcode );
#else
  dinb_process_select( db, select_dp /* globalContext, &sqlca*/ );
#endif

end_exec_select:
  /* keep the sqlca error data */
  CodeError = sqlca.sqlcode ;
  snprintf( sqlcaKeepMsg, 70, "%s", sqlca.sqlerrm.sqlerrmc );
  sqlcaKeepLen = sqlca.sqlerrm.sqlerrml ;
  EXEC SQL WHENEVER SQLERROR CONTINUE ;
  /* Close the cursor. */
#ifdef DEBUG_TRACE
      fprintf(of, "t%d - dinb_exec_select - close cursor C1\n", thr_self() );
      fflush( of );
#endif
  EXEC SQL AT :db CLOSE C1; 
  /* get back the sqlca  */
  sqlca.sqlcode = CodeError;
  snprintf( sqlca.sqlerrm.sqlerrmc, 70, "%s", sqlcaKeepMsg );
  sqlca.sqlerrm.sqlerrml = sqlcaKeepLen ;

  /* force error for test : do not forget to define the message length !
  snprintf( sqlca.sqlerrm.sqlerrmc, 70, "added manually" );
  sqlca.sqlerrm.sqlerrml = 14 ;
  sqlca.sqlcode = 99999 ;
  */
  /*  memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
  return sqlca.sqlcode;
}   

#ifdef DEBUG_TRACE
int dinb_process_select( char* db, /* SQLDA* bind_dp, */ SQLDA* select_dp,
			 /* sql_context* globalContext, */
			 /*struct sqlca* localSqlca,*/
			 FILE* of ) {
#else
int dinb_process_select( char* db, /* SQLDA* bind_dp, */ SQLDA* select_dp
			 /* sql_context* globalContext, */
			 /*struct sqlca* localSqlca*/
			 ) {
#endif

    int i=0, null_ok=0, precision=0, scale=0;
    int j=0; int k=0;
    /*    struct sqlca sqlca ;*/

#ifdef DEBUG_TRACE
    fprintf( of, "t%d - get in dinb_process_select\n", thr_self() );
#endif
 
    char** tabGeneric = (char**) 0;
    char* pteur = NULL;   
    short** tabInd = (short**) 0;

    /* printf("DEBUG: thread %d dinb_process_select called with context Ox%X\n",pthread_self(),*globalContext); */
    tabGeneric = (char** ) malloc(select_dp->N * sizeof(char*));
    tabInd = (short** ) malloc(select_dp->N * sizeof(short*));

    for (i = 0; i < select_dp->N; i++) {
      tabGeneric[i] = (char*) malloc( ( ( select_dp->L[i] ) * batchRecordSize ) + 1 );
      select_dp->V[i] = (char*) tabGeneric[i];
      tabInd[i] = (short *) malloc( sizeof( short ) * batchRecordSize );
      select_dp->I[i] = (short *) tabInd[i];

      /* printf( "select_dp->I[%d] has size : %d * %d = %d from @%x\n",
	 i, sizeof(short), batchRecordSize, ( sizeof(short)*batchRecordSize ), select_dp->I[i] ); 
      */
    }
 
    /* FETCH each row selected and print the column values. */
    EXEC SQL WHENEVER NOT FOUND GOTO end_process_select;
    EXEC SQL WHENEVER SQLERROR GOTO end_process_select1 ;

    
    for(;;) {
      /*printf( "next fetch\n" );*/  /* loop because I forgot to code SQLERROR goto */
      EXEC SQL AT :db FOR :batchRecordSize FETCH C1 USING DESCRIPTOR select_dp ; 
      /* for (j=k; j<sqlca.sqlerrd[2]; j++) {
	 printf("DEBUG: Thread %d: Row %d ",pthread_self(), j);
	 for( i = 0; i < select_dp->N ; i++ ) {
	 printf(" Type: %d data: %s ", select_dp->T[i], select_dp->V[i]);
	 }
	 printf("\n");
	 }
	 k=j;
      */
      for( i = 0; i < select_dp->N ; i++ ) {
	tabGeneric[i] = (char*) realloc(tabGeneric[i],
					((select_dp->L[i]) 
					 * 
					 (batchRecordSize + sqlca.sqlerrd[2]))
					+ 1
					);
	  
	select_dp->V[i] = (char*) &tabGeneric[i][(select_dp->L[i])
						 *
						 sqlca.sqlerrd[2]];

	tabInd[i] = (short *) realloc(tabInd[i],
				      sizeof(short)
				      * 
				      (batchRecordSize + sqlca.sqlerrd[2]));

	select_dp->I[i] = (short *) &tabInd[i][sqlca.sqlerrd[2]];
	
      }


    }
end_process_select1 :
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
#ifdef DEBUG_TRACE
    fprintf( of, "process_select : an error occured : %d '%s'\n",
	    sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc );
#endif
    /*    memcpy( localSqlca, &sqlca, sizeof(struct sqlca) );*/
    return 0 ;

end_process_select:
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    sqlca.sqlcode = 0 ;
    
    for (i = 0; i < select_dp->N ; i++) {
      tabGeneric[i] = (char*) realloc(tabGeneric[i],
				      ((select_dp->L[i]) 
				      * 
				      sqlca.sqlerrd[2])
				      + 1
				      );	  
      select_dp->V[i] = (char*) tabGeneric[i];

      tabInd[i] = (short *) realloc(tabInd[i],
				    sizeof(short)
				    *
				    sqlca.sqlerrd[2]);	

      select_dp->I[i] = (short *) tabInd[i];
    }
    free(tabInd);
    free(tabGeneric);
    /*    memcpy( localSqlca, &sqlca, sizeof( struct sqlca ) );*/
    return 0;
}
